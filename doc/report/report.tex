%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UNIVOTE LATEX TEMPLATE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[bibtotoc,halfparskip,oneside]{scrreprt}

\usepackage{import}
\import{../latex/}{english.tex} 
% you must set the path according to the current document folder
% use "german.tex" for documents in german and "english.tex" for documents in english
\inputpath{{listings/}{figures/}}

\usepackage{enumitem}

\setcounter{secnumdepth}{4}
\renewcommand{\thesubsubsection}{\alph{subsubsection}}
\renewcommand*{\othersectionlevelsformat}[3]{% 
  #3% 
  \begingroup 
    \edef\istlevel{#1}\def\solllevel{subsubsection}% 
    \ifx\istlevel\solllevel )\else\autodot\fi 
  \endgroup 
  \enskip 
} 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definition of Symbols
% Note: Every symbol defined here should be mentioned in the glossary
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\eid}{\mathit{id}\xspace}
\newcommand{\descr}{\mathit{descr}\xspace}
\newcommand{\cred}[1]{cred_{#1}\xspace}

\newcommand{\sk}[1]{\mathit{sk}_{#1}\xspace}
\newcommand{\vk}[1]{\mathit{vk}_{#1}\xspace}
\newcommand{\vkprime}[1]{\mathit{vk}'_{#1}\xspace}
\newcommand{\vkbar}[1]{\bar{\mathit{vk}}_{#1}\xspace}
\newcommand{\vkbarprime}[1]{\bar{\mathit{vk}}'_{#1}\xspace}
\newcommand{\vkhat}[1]{\hat{\mathit{vk}}_{#1}\xspace}
\newcommand{\vkhatprime}[1]{\hat{\mathit{vk}}'_{#1}\xspace}

\newcommand{\SK}[1]{\sk{_#1}\xspace}
\newcommand{\VK}[1]{\vk{_#1}\xspace}

\newcommand{\RA}{\ensuremath{\mathit{RA}}\xspace}
\newcommand{\CA}{\ensuremath{\mathit{CA}}\xspace}
\newcommand{\EA}{\ensuremath{\mathit{EA}}\xspace}
\newcommand{\EC}{\ensuremath{\mathit{EC}}\xspace}
\newcommand{\UB}{\ensuremath{\mathit{UB}}\xspace}
\newcommand{\Tallier}[1]{\ensuremath{\mathit{T}_{#1}}\xspace}
\newcommand{\Mixer}[1]{\ensuremath{\mathit{M}_{#1}}\xspace}
\newcommand{\Voter}[1]{\ensuremath{\mathit{V}_{#1}}\xspace}



\begin{document}

\title{UniVote System Specification}
\maketitle

\begin{versionhistory}
	\vhEntry{0.1}{14.07.2012}{Rolf Haenni}{Initial Draft.}
	\vhEntry{0.2}{15.08.2012}{Rolf Haenni}{Complete revision of initial draft.}
	\vhEntry{0.3}{10.09.2012}{Rolf Haenni}{Includes now the case of late registrations.}
	\vhEntry{0.4}{13.03.2013}{Rolf Haenni}{Improved ballot acceptance and closing the urn.}
	\vhEntry{0.5}{04.04.2013}{Rolf Haenni}{Revised section on zero-knowledge proofs.}
	\vhEntry{0.5.1}{30.04.2013}{Rolf Haenni}{Improved notational consistency.}
	\vhEntry{0.5.2}{21.05.2013}{Rolf Haenni}{Two important notational corrections.}
\end{versionhistory}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter*{Abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{System Requirements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{Cryptographic Protocol}
\chapter{Cryptographic Primitives \& Encodings}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%===============================================================================================
\section{Cryptographic Primitives}
%===============================================================================================

The UniVote system is based on several cryptographic building blocks. Apart from standard ElGamal encryption and decryption, we also need Schnorr signatures, threshold decryptions, non-interactive zero-knowledge proofs of knowledge, verifiable exponentiation and re-encryption mix-nets, an anonymous channel, and an append-only public bulletin board. These building blocks will be briefly described below.

%-----------------------------------------------------------------------------------------------
\subsection{ElGamal Cryptosystem} 
%-----------------------------------------------------------------------------------------------

The \emph{ElGamal cryptosystem} is based on a multiplicative cyclic group $(G_q,\cdot,1)$ of order $q$, for which the decisional Diffie-Hellman assumption (DDH) is believed to hold \cite{gamal84}. The most common choice for such a group is the subgroup of quadratic residues $G_q\subset\mathbb{Z}_p^*$ of prime order $q$, where $p=2q+1$ is a \emph{safe prime}. Typically, $p$ is chosen to be large enough (1024--2048 bits) to resist index-calculus and other methods of solving the discrete logarithm problem. The public parameters of an ElGamal cryptosystem are thus $p$, $q$, and a generator $g$ of $G_q=\langle g\rangle$. A suitable generator can be found by picking an arbitrary value $\gamma\in\mathbb{Z}_p^*$ and by checking that $g=\gamma^2$ is different from $1$.

An ElGamal key pair is a tuple $(x,y)$, where $x\in_R\mathbb{Z}_q$ is the randomly chosen private decryption key and $y=g^x\in G_q$ the corresponding public encryption key. If $m\in G_q$ denotes the plaintext to encrypt, then 
\begin{align}
	\mathit{Enc}_y(m,r)=(g^r,m\cdot y^r)\in G_q\times G_q
\end{align} 
is the ElGamal encryption of $m$ with randomization $r \in_R\mathbb{Z}_q$.\footnote{For improved efficiency, we can pick a randomization $r$ with a reduced, but large enough bit-length to resist birthdate attacks on discrete logarithms (160--512 bits). Furthermore, we can pre-compute both parts of an ElGamal encryption prior to knowing the plaintext $m$.} Note that its bit-length is twice the bit-length of $p$. For a given encryption $E=(a,b)=\mathit{Enc}_y(m,r)$, $m$ can be recovered by using the private decryption key $x$ to compute 
\begin{align}
	\mathit{Dec}_x(E)=a^{-x}\cdot b = m.
\end{align} 
Note that $m$ can also be recovered by $m=b\cdot y^{-r}$ in case the randomization $r$ is known. 

The ElGamal encryption function is \emph{homomorphic} with respect to multiplication, which means that the component-wise multiplication of two ciphertexts yields an encryption of the product of respective plaintexts:
\begin{align}
	\mathit{Enc}_y(m_1,r_1)\cdot\mathit{Enc}_y(m_2,r_2)=\mathit{Enc}_y(m_1\cdot m_2,r_1+r_2).
\end{align}
In a homomorphic cryptosystem like ElGamal, a given encryption $E=\mathit{Enc}_y(m,r)$ can be \emph{re-encrypted} by multiplying $E$ with an encryption of the neutral element $1$. The resulting re-encryption, 
\begin{align}
	\mathit{ReEnc}_y(E,r')=E\cdot\mathit{Enc}_y(1,r')=\mathit{Enc}_y(m,r+r'),
\end{align}
is clearly an encryption of $m$ with a fresh randomization $r+r'$.

Practical applications often require the plaintext to be selected from $\mathbb{Z}_q$ rather than $G_q$. With a safe prime $p$, we can use the following mapping $G:\mathbb{Z}_q\rightarrow G_q$ to encode any integer plaintext $m'\in\mathbb{Z}_q$ by a group element $m\in G_q$, which can then be encrypted as described above:
\begin{align}
	m=G(m')=
	\begin{cases}
		m'+1,&  \text{if}~ (m'+1)^q=1,\\
		p-(m'+1),&  \text{otherwise}.
	\end{cases}
\end{align}
When we obtain $m\in G_q$ from decrypting the ciphertext, we can reconstruct $m'\in\mathbb{Z}_q$ by applying the inverse function $G^{-1}:G_q \rightarrow \mathbb{Z}_q$ to $m$:
\begin{align}
	m'=G^{-1}(m)=
	\begin{cases}
		m-1,&  \text{if}~ m \leq q,\\
		(p-m)-1,&  \text{otherwise}.
	\end{cases}
\end{align}
Note that by adding such an encoding to the ElGamal cryptosystem, it is no longer homomorphic with respect to plaintexts in $\mathbb{Z}_q$ (but re-encryptions can still be computed in the same way as explained above).

%-----------------------------------------------------------------------------------------------
\subsection{Schnorr Signatures} 
%-----------------------------------------------------------------------------------------------

The \emph{Schnorr signature scheme} has a setting similar to the ElGamal cryptosystem. It is based on a multiplicative cyclic group $(G_q,\cdot,1)$ of order $q$, for which the discrete logarithm problem (DLP) is believed to be intractable in the random oracle model \cite{schnorr91}. The most common choice is a \emph{Schnorr group}, a subgroup $G_q\subset\mathbb{Z}_p^*$ of prime order $q$, where $p=kq+1$ is a  prime large enough (1024--2048 bits) to resist methods for solving the discrete logarithm problem, while $q$ is large enough (160--512 bits) to resist birthday attacks on discrete logarithm problems. The public parameters of a Schnorr signature scheme are thus $p$, $q$, and a generator $g$ of $G_q=\langle g\rangle$. A suitable generator can be found by picking a random value $\gamma\in_R\mathbb{Z}_p^*$ and by checking that $g=\gamma^k$ is different from $1$. Furthermore, all involved parties must agree on a cryptographic hash function $H:\{0,1\}^*\rightarrow \mathbb{Z}_q$.\footnote{We can choose any cryptographic hash with the desired security properties by applying modulo $q$ to the integer interpretation of its hash value. For example, \ $H(x)=\mathrm{SHA\text{-}256}(x)\bmod{q}$.}

An Schnorr signature key pair is a tuple $(sk,vk)$, where $sk\in_R\mathbb{Z}_q$ is the randomly chosen private signature key and $vk=g^{sk}\in G_q$ the corresponding public verification key. If $m\in\{0,1\}^*$ denotes an arbitrary message to sign and $r\in_R\mathbb{Z}_q$ a randomly selected value, then \begin{align}
	\mathit{Sign}_{sk}(m,r)=(a,r-a\cdot sk)\in \mathbb{Z}_q\times \mathbb{Z}_q,~\text{where $a=H(m||g^r)$},
\end{align}
is the Schnorr signature of $m$. Note that its bit-length is twice the bit-length of $q$. Using the public verification key $vk$, a given signature $S=(a,b)=\mathit{Sign}_{sk}(m,r)$ for message $m$ can be verified by computing
\begin{align}
	\mathit{Verify}_{\vk{}}(m,S)=\begin{cases}
	\mathit{accept}, & \text{if}~ a = H(m||g^b\cdot vk^a),\\
	\mathit{reject}, & \text{otherwise}.
	\end{cases}
\end{align}

%-----------------------------------------------------------------------------------------------
\subsection{Digital Certificates} 
%-----------------------------------------------------------------------------------------------

Let $m=id||k||t||\CA$ denote a particular type of message, where $id$ is a unique identifier of the holder of a public encryption or signature key $k$, $t$ a timestamp, and $\CA$ the identifier of a \emph{certificate authorithy} with public verification key $\VK{\CA}$ and private signature key $\SK{\CA}$. Let $S_{id}=\mathit{Sign}_{\SK{\CA}}(id||k||t||\CA,r)$ be a digital signature of $m$ for some randomization $r\in_R\mathbb{Z}_q$. Then 
\begin{align}
	Z_{id}=\mathit{Certify}_{\SK{\CA}}(id,k,t)=(id,k,t,\CA,S_{id})
\end{align}
is \emph{digital certificate} of $k$ issued by $\CA$ at time $t$. It can be verified by checking that $\mathit{Verify}_{\VK{\CA}}(Z_{id})=\mathit{Verify}_{\VK{\CA}}(id||k||t||\CA,S_{id})=\mathit{accept}$.

%-----------------------------------------------------------------------------------------------
\subsection{Zero-Knowledge Proofs of Knowledge}\label{zip}
%-----------------------------------------------------------------------------------------------

A \emph{zero-knowledge proof} is a cryptographic protocol, where the \emph{prover} $P$ tries to convince the \emph{verifier} $V$ that a mathematical statement is true, but without revealing any  information other than the truth of the statement. A \emph{proof of knowledge} is a particular proof allowing $P$ to demonstrate knowledge of a secret information involved in the mathematical statement.

\subsubsection{Non-Interactive Preimage Proof}

One of the most fundamental zero-knowledge proofs of knowledge is the \emph{preimage proof}. Let $(X,+,0)$ be an additively written and $(Y,\cdot,1)$ a multiplicatively written group of finite order, and let $\phi:X\rightarrow Y$ a one-way group homomorphism. If $P$ knows the preimage $a\in X$ (the \emph{private input}) of a publicly known value $b=\phi(a)\in Y$ (the \emph{public input}), then proving knowledge of $a$ is achieved with the following non-interactive version of the \emph{$\Sigma$-protocol}. To generate the proof, $P$ performs the following steps:
\begin{enumerate}
	\item Choose $\omega\in_R X$ uniformly at random.
	\item Compute $t=\phi(\omega)$.
	\item Compute $c = H(b,t) \bmod{q}$, for $q=|\text{image}(\phi)|$.
	\item Compute $s = \omega + c\cdot a$.
\end{enumerate}
The pair $\pi=(t,s)$ is the resulting proof which can be published without revealing any information about $a$. Note that $\text{image}(\phi)=Y$ holds in many concrete instantiations of the  preimage proof, and this implies $q=|Y|$. To verify $\pi$, the $V$ computes $c = H(b,t) \bmod{q}$ and checks if $\phi(s)\stackrel{?}{=}t\cdot b^c$ holds.

\subsubsection{Examples}

\minisec{Knowledge of Discrete Logarithm (Schnorr)}
	\begin{itemize}
		\item Let $g$ be a generator of $G_q$
		\item Let $c=g^m $ be a publicly known commitment of $m\in\mathbb{Z}_q$ 
		\item $P$ proves knowledge of $m$ using the $\Sigma$-protocol for:
		\begin{align*}
			 &a = m,\\
			 &b = c,\\
			 &\phi(x)=g^x,
		\end{align*}
		where $\phi:\underbrace{\mathbb{Z}_q}_X\rightarrow \underbrace{G_q}_Y$
	\end{itemize}

\minisec{Equality of Discrete Logarithms}
	\begin{itemize}
		\item Let $g_1$ and $g_2$ be generators of $G_q$
		\item Let $c_1=g_1^{m}$ and $c_2=g_2^{m}$ be public commitments of $m\in\mathbb{Z}_q$ 
		\item $P$ proves knowledge of $m$ using the $\Sigma$-protocol for:
		\begin{align*}
			 &a=m,\\
			 &b=(c_1,c_2),\\
			 &\phi(x)=(g_1^{x},g_2^{x}),
		\end{align*}
		where $\phi:\underbrace{\mathbb{Z}_q}_X\rightarrow \underbrace{G_q\times G_q}_Y$
		\item Note that $t=(t_1,t_2)$
	\end{itemize}

\subsubsection{Composition of Preimage Proofs}

\minisec{AND Composition}
	\begin{itemize}
		\item Consider $n$ one-way group homomorphism $\phi_i:X_i\rightarrow Y_i$ 
		\item Let $b_1,\ldots,b_n$ be publicly known, where $b_i=\phi_i(a_i)$
		\item $P$ proves knowledge of $a_1,\ldots,a_n$ using the $\Sigma$-protocol for:
		\begin{align*}
			&a=(a_1,\ldots,a_n),\\
			&b=(b_1,\ldots,b_n),\\
			&\phi(x_1,\ldots,x_n)=(\phi_1(x_1),\ldots,\phi_n(x_n)),
		\end{align*}
		where $\phi: \underbrace{X_1\times\cdots\times X_n}_X\rightarrow \underbrace{Y_1\times\cdots\times Y_n}_Y$
		\item Note that $\omega=(\omega_1,\ldots,\omega_n)$, $t=(t_1,\ldots,t_n)$, $s=(s_1,\ldots,s_n)$, which implies proofs of size $O(n)$
	\end{itemize}

\minisec{Equality Proof}
	\begin{itemize}
		\item Consider $n$ one-way group homomorphism $\phi_i:X\rightarrow Y_i$ 
		\item Let $b_1,\ldots,b_n$ be publicly known, where $b_i=\phi_i(a)$
		\item $P$ proves knowledge of $a$ using the $\Sigma$-protocol for:
		\begin{align*}
			&a,\\
			&b=(b_1,\ldots,b_n),\\
			&\phi(x)=(\phi_1(x),\ldots,\phi_n(x)),
		\end{align*}
		where $\phi: X\rightarrow \underbrace{Y_1\times\cdots\times Y_n}_Y$
		\item Note that $t=(t_1,\ldots,t_n)$, which implies proofs of size $O(n)$
	\end{itemize}


%-----------------------------------------------------------------------------------------------
\subsection{Threshold Cryptosystem} 
%-----------------------------------------------------------------------------------------------

A cryptosystem such as ElGamal is called threshold cryptosystem, if the private decryption key $x$ is shared among $n$ parties, and if the decryption can be performed by a threshold number of parties $t \leq n$ without explicitly reconstructing $x$ and without disclosing any information about the individual key shares $x_i$. A general threshold version of the ElGamal cryptosystem results from sharing the private key $x$ using Shamir's secret sharing scheme \cite{pedersen91,shamir79b}. To avoid the need for a trusted third party to generate the shares of the private key, it is possible to let the $n$ parties execute a distributed key generation protocol \cite{GJKR99}. We do not further introduce these techniques here, but we will assume their application throughout this paper, for example by saying that some parties jointly generate a private key or that they jointly decrypt a ciphertext.

A threshold cryptosystem, which is limited to the particular case of $t=n$, is called \emph{distributed cryptosystem}. A simple distributed version of the ElGamal cryptosystem results from setting $x=\sum_i x_i$. To avoid that $x$ gets publicly known, each of the $n$ parties secretly selects its own key share $x_i \in_R\mathbb{Z}_q$ and publishes $y_i=g^{x_i}$ as a commitment of $x_i$. The product $y=\prod_i y_i = g^{\sum_i x_i}=g^x$ is then the common public encryption key. If $E=(a,b)=\mathit{Enc}_y(m,r)$ is a given encryption, then $m$ can be jointly recovered if each of the $n$ parties computes $a_i=a^{-x_i}$ using its own key share $x_i$. The resulting product $a^{-x}=\prod_i a_i$ can then be used to derive $m=\mathit{Dec}_x(E)=a^{-x}\cdot b$ from $b$.\footnote{Alternatively, each party may compute $m_i=\mathit{Dec}_{x_i}(E)=a^{-x_i}\cdot b$ by applying the normal ElGamal decryption function. The plaintext message can then be recovered by $m=b^{1-n}\cdot\prod_i m_i$.} Instead of performing this simple operation in parallel, it is also possible to perform essentially the same operation sequentially in form of a \emph{partial decryption function} $\mathit{Dec}'_{x_i}(E)=(a,a^{-x_i}\cdot b)$. Applying $\mathit{Dec}'_{x_i}$ ``removes'' from $E$ the public key share $y_i$ by transforming it into a new encryption $E'=\mathit{Dec}'_{x_i}(E)$ for a new public key $y\cdot y_i^{-1}$. If all public key shares are removed in this way (in an arbitrary order), we obtain a trivial encryption $(a,m)$ from which $m$ can be extracted.

To guarantee the correct outcome of a threshold or distributed decryption, all involved must prove that they followed the protocol properly. In the case of the above distributed version of the ElGamal cryptosystem, each party must deliver two types of non-interactive zero-knowledge proofs:
\begin{itemize}
\item $\mathit{NIZKP}\{(x_j):y_j=g^{x_j}\}$, to prove knowledge of the discrete logarithm of $y_j$ after committing to $x_j$,
\item $\mathit{NIZKP}\{(x_j):y_j=g^{x_j} \wedge a_j=a^{-x_j}\}$, to prove equality of the discrete logarithms of $y_j$ and $a_j^{-1}$ after computing $a_j$.
\end{itemize}
Note that the first proof seems to be subsumed by the second proof, but it is important to provide the first proof along with $y_j$ to guarantee the correctness of $y$ \emph{before} using it as a public encryption key.

If $\{E_1,\ldots,E_N\}$ is a batch of encryptions $E_i=(a_i,b_i)$ to decrypt and $a_{ij}=a_i^{-x_j}$ the corresponding partial decryptions, then it is more efficient to provide a single combined  proof,
\begin{align}
\mathit{NIZKP}\{(x_j):y_j=g^{x_j} \wedge (\bigwedge_i a_{ij}=a_i^{-x_j})\},
\end{align}
instead of $N$ individual proofs of the second type. As discussed in \subsecref{zkp}, a combined proof like this can be implemented efficiently as a batch proof.

%-----------------------------------------------------------------------------------------------
\subsection{Verifiable Mix-Nets}
%-----------------------------------------------------------------------------------------------

\emph{not yet implemented}
%===============================================================================================
\chapter{UniBoard}
%===============================================================================================
A bulletin board allows  a group of writers to post public messages, so that they can be read by anybody. Furthermore it can have various properties, which each provide different guarantees or extend the capabilities of the board.

To give one flexibility in their bulletin board implementation UniBoard specifies a common interface and a component model. This allows one to combine different properties as the need arrives or to write their own implementation of a certain property. 

UniVote and UniCert both use UniBoard for their public messages. In both cases, the same set of properties are required. In this chapter, these properties are introduced one by one and their descriptions show the concrete operations calls used in UniVote and UniCert, building up on the arguments introduced by previous properties.



% and the concrete instanciation of the operation is described, taking the previous described properties into account. 
%
%and the derived operations 
%and the concrete operations signature are expanded
%the concretization of the methods is described
%With each property we (expand) concretize the concrete operation calls used for UniVote and UniCert
%
%with each property it shows how the concrete operation call used for unite univcert expands
%building up on the previous.

%\section{Properties}
\section{Single purpose or multipurpose}

UniBoard supports two modes, single purpose (a single application uses the bulletin board) and multipurpose (multiple applications can use it). In the single purpose mode the two basic operations look like this:

\begin{itemize}
	\item Post$(m,A):B$ \newline This operation allows to publish on UniBoard a message $m \in \mathcal{M}$ and additional arguments $A=(\alpha_1,\dots,\alpha_n)$, where $\alpha_j \in \mathcal{A}_j$. UniBoard might add additional arguments $B=(\beta_1,\dots,\beta_k)$, where $\beta_j \in \mathcal{B}_j$, and stores the post $p=(m,A,B)$ in $\mathcal{P}_{UB}$. UniBoard returns the additional arguments $B$. The arguments in $A$ and $B$ depend on the properties supported by UniBoard.
	\item Get$(Q):R$ \newline This operation allows to get the published data $\mathcal{P}_{UB}$ from UniBoard as result $R$. The result $R$ for a query $Q=(\mathcal{A}'_1, \dots , \mathcal{A}'_n, \mathcal{B}'_1, \dots, \mathcal{B}'_k)$, where $\mathcal{A}'_i \subseteq  \mathcal{A}_i$ and  $\mathcal{B}'_j \subseteq  \mathcal{B}_j$, is the set of posts $R\subseteq\mathcal{P}_{UB}$ such that each $p\in R$ fulfils $\alpha_i \in \mathcal{A}'_i$ and $\beta_j \in \mathcal{B}'_j$. $Q$ enables one to retrieve only the information one is interested in by reducing $\mathcal{A}'_1, \dots , \mathcal{A}'_n$ and $\mathcal{B}'_1, \dots , \mathcal{B}'_k$ to the desired values. 
	%If $\mathcal{A}'_i$ or $\mathcal{B}'_j$ is missing in $Q$ it is assumed to be equal to $\mathcal{A}_i$ or $\mathcal{B}_j$ respectively.
\end{itemize}


In the multipurpose mode, since applications have different needs regarding board properties, the board must allow application $i$ to define its own set of properties. Moreover, each application also defines its own sets $\mathcal{A}_{ij}$ and $\mathcal{B}_{ij}$ of possible values for the arguments $A$ and $B$ where $\alpha_{ij} \in \mathcal{A}_{ij}$ and $\beta_{ij} \in \mathcal{B}_{ij}$. So, the basic operations must be extended with an application identifier $i$.

\begin{itemize}
	\item Post$(i, m, A):B$
	\item Get$(i, Q):R$ 
\end{itemize}

%The configuration of UniBoard for UniVote uses the multipurpose mode since UniVote and UniCert both use UniBoard. 
Because UniBoard is used for UniCert and UniVote, the configuration uses the multipurpose mode.
%To allow one to retrieve all application identifiers, a default application $i_0$="root" is defined where for each known application UniBoard posts a message containing the application identifier $a$.


%\section{UniBoard properties for UniVote}
%
%For the use of UniVote, UniBoard is used as bulletin board. UniVote require following properties for the board:
%
%\begin{itemize}
%	\item Sectioned
%	\item Grouped
%	\item Typed
%	\item Access-controlled
%	\item Certified posting
%	\item Certified reading
%	\item Append-only
%	\item Notifying / Active notification
%	\item Searchable
%\end{itemize}
%
%The properties needed for these applications are be described below showing which effect they have on the basic operations described earlier.

\subsection{Sectioned}

Inside a bulletin board with this property, an application can be divided into multiple sections. E.g.: separate data for different customers into individual sections. To realize this property, $\alpha_{i1}$ is used as section identifier. So, $\mathcal{A}_{i1}$ represents the set of all existing section identifiers for application $i$.

\begin{itemize}
	\item Post$(i, m, (\alpha_{i1})):()$
	\item Get$(i, (\mathcal{A}'_{i1})):R$ 
\end{itemize}

%An additional operation must be introduced allowing to ask the board for all the sections inside an application:
%\begin{itemize}
%	\item GetAllSections$(i):\mathcal{A}_1$ \newline
%	The operation returns the set of all section identifiers  $\mathcal{A}_1$ for application $i$. 
%\end{itemize}

\subsection{Grouped}

In a grouped bulletin board, messages are organized into groups defined by the application. A group identifier  $\alpha_{i2}$ must be provided on posting. So, $\mathcal{A}_{i2}$ represents the set of all existing group identifiers for application $i$. 

\begin{itemize}
	\item Post$(i, m, (\alpha_{i1}, \alpha_{i2})):()$
	\item Get$(i, (\mathcal{A}'_{i1}, \mathcal{A}'_{i2})):R$ 
\end{itemize}

%An additional operation must be introduced allowing to ask the board for all the groups inside an application:
%\begin{itemize}
%	\item GetAllGroups$(i):\mathcal{A}_2$ \newline
%	The operation returns the set of all group identifiers  $\mathcal{A}_2$ for application $i$. 
%\end{itemize}

% message $m$ always belongs to a message type $T_j$ where $T_j\in\mathcal{A}_i$. Therefore a message type $T_j$ is added to the list of parameters $A$ when posting a message.

\subsection{Typed}

This property depends on the grouped property. It defines for each group $g$ the set of correct messages $\mathcal{M}_g$ enabling the board to validate that each incoming message $m$ for group $g$ is in $\mathcal{M}_g$. 

%The typed property requires a schema of the message structure to be provided. On posting, the bulletin board has to check the structure of $m$ with the proposed schema. Inside a group, all messages are from the same type.
%The typed property requires the structured property. Moreover, for each type of message, a schema of the message structure must be provided for the board verifies the content structure of every incoming message. For that, an additional method must be introduced:

%\begin{itemize}
%	\item SetMessageStructureScheme$(scheme)$ : -
%\end{itemize}

%\begin{itemize}
%	\item Post$(message,T_k)$ : -
%	\item Get$(T_k)$ : $\mathcal{R}_k$ where $(m,T_k) \in \mathcal{R}_k$
%\end{itemize}

\subsection{Access-controlled}

The goal of the access-controlled property is to allow only authorized entities to publish one, a defined number or an undefined number of messages on the board. This check is done by verifying if the signer of the posted message is allowed to publish. Therefore, a signature from the poster must be added when posting. $\alpha_3$ is used for this purpose. So, $\mathcal{A}_3$ represents the set of all valid signatures.

%\begin{itemize}
%	\item Post$(message,t,s)$ : -
%	\item Get$()$ : $\mathcal{R}_\UB$ where $(m,s,t) \in \mathcal{R}_\UB$
%\end{itemize}

\subsection{Certified Posting}

Upon posting a message $m$, UniBoard creates the signature $S_m(m,i,A,B,t_{\mathcal{UB}})$ including the message, the application identifier $i$, the $A$ and $B$ arguments and the current timestamp $t_\mathcal{UB}$. Timestamp and signature are returned in arguments $\beta_1$ and $\beta_2$ respectively. So, the Post operation must be adapted and becomes:

\begin{itemize}
	\item Post$(m,i,A): (B, S_m,t_\mathcal{UB})$
\end{itemize}

TODO: are $S_m$ and $t$ B arguments => $S_m = \beta_1$ and $t = \beta_2$\\
TODO: query possibilities

\subsection{Certified Reading}

When querying the board, it creates a signature $S_q(Q,R,t_\mathcal{UB})$ over the query $Q$, the result $R$ and the timestamp $t_\mathcal{UB}$ of the query process. For this property, the Get operation must be adapted as follows:

\begin{itemize}
	\item Get$(Q): (R, S_q, t_\mathcal{UB})$
\end{itemize}

TODO introduce the verification operation done by the user. In the Univote specs, we then can reference on this instead of rewriting it each time





\subsection{Append-Only}

The append-only property ensures that no already published message can be removed from the board. So, $\mathcal{UB}_t \subseteq \mathcal{UB}_{t+1}$ where $\mathcal{UB}_{t} $ represent the content on the board at time $t$.

TODO is the signature of the method modified ?

\subsection{Notifying}

The notification property of the board allows an entity to register itself to be notified when a certain type of message is posted on the board. In order to accomplish that, two additional methods must be introduced:

\begin{itemize}
	\item RegisterForNotification$(entity, T )$ : -
	\item UnregisterNotifications$(entity, T)$ : -
\end{itemize}





\subsection{Searchable}

The searchable property allow to query not only attributes $A$ and $B$, but also indicate attributes $C$ that must be found in the message itself. The Get operation must be modified as follow:

\begin{itemize}
	\item Get$(Q):R$ \newline The result $R$ for a query $Q=(\mathcal{A}'_1, \dots , \mathcal{A}'_n, \mathcal{B}'_1, \dots, \mathcal{B}'_k, \mathcal{C}'_1, \dots, \mathcal{C}'_l)$, where $\mathcal{A}'_i \subseteq  \mathcal{A}_i$ and  $\mathcal{B}'_j \subseteq  \mathcal{B}_j$ and $\mathcal{C}'_f \subseteq  \mathcal{M}$, is the set of tuples $(m,A,B)$ such that $\alpha_i \in \mathcal{A}'_i$ and $\beta_j \in \mathcal{B}'_j$, and $\mathcal{C}'_f = m'$ where $m'$ is a portion of $m$. 
\end{itemize}

TODO check if this description is correct

\subsection{Combination of multiple properties}

All the properties mentioned earlier can be combined together. So, for example, a board with properties multipurpose, sectioned, structured, typed, access-controlled, notifying, append-only, certified reading, certified posting and searchable would have following operations:

\begin{itemize} 
	\item Post$(m,a_i,e_j,T,s,): (B,S_m,t_\UB)$
	\item Get$(Q): (R, S_q, t_\UB)$ where $Q=(\mathcal{A}'_1, \dots , \mathcal{A}'_n, \mathcal{B}'_1, \dots, \mathcal{B}'_k, \mathcal{C}'_1, \dots, \mathcal{C}'_l)$
	\item SetMessageStructureScheme$(scheme)$ : -
	\item RegisterForNotification$(entity, T )$ : -
	\item UnregisterNotifications$(entity, T)$ : -
\end{itemize}



%===============================================================================================
\chapter{UniCert}
%===============================================================================================

%===============================================================================================
\chapter{UniVote}
%===============================================================================================

%===============================================================================================
\section{Overview}
%===============================================================================================

Involved parties:

\begin{description}
	\item[Certificate Authority.] \CA
	\item[Election Administration.] \EA
	\item[Election Coordinator.] \EC
	\item[Uniboard.] \UB
	\item[Talliers.] $\Tallier{1},\ldots,\Tallier{r}$
	\item[Mixers.] $\Mixer{1},\ldots,\Mixer{m}$
	\item[Voters.] $\Voter{1},\ldots,\Voter{n}$
\end{description}

Number of ballots: $N\leq n$

%===============================================================================================
\section{Detailed Protocol Specification}
%===============================================================================================

%-----------------------------------------------------------------------------------------------
\subsection{Public Parameters}
%-----------------------------------------------------------------------------------------------

The following parameters are assumed to be known in advance and not to change over time.

Schnorr signature scheme:
\begin{itemize}
\item $p=
161931481198080639220214033595931441094586304918402813506510547237223\\ 7877754754259914439249774193306631702245697880199001800501144684304139086\\ 8732987125110128087878658851566801277279829851162163414546460062661954882\\ 3238185390034868354933050128115662663653841842699535282987363300852550784\\188180264807606304297$ (1024 Bits)
\item $q=(p-1)/k=65133683824381501983523684796057614145070427752690897588060\\462960319251776021$ (256 Bits)
\item $g=
109291242937709414881219423205417309207119127359359243049468707782004\\ 8626824418974327801277343955962753772182364420355348252837257828360264395\\ 3768769508441079722879300473967183506141904091215758360742296555142874914\\ 9162882960112513332411954585778903685207256083057895070357159920203407651\\236651002676481874709$ (1024 Bits)
\end{itemize}

Hash function: (used in Schnorr signatures and zero-knowledge proofs)
\begin{itemize}
\item $H(x)=\mathrm{SHA\text{-}256}(x)\bmod{q}$
\end{itemize}

%-----------------------------------------------------------------------------------------------
\subsection{Public Identifiers and Keys}
%-----------------------------------------------------------------------------------------------

Certificates for the following identifiers are assumed to be available in a public certificate directory.

\subsubsection{Registration System}


Certificate authority:
\begin{itemize}
	\item Identifier: \CA
	\item Public certificate: $Z_{\CA}$, self-signed or certified by public certification authority at time $t$
	\item Public verification key: $\VK{\CA}$
	\item Private signature key: $\SK{\CA}$
\end{itemize}

\subsubsection{Election System}

Election Coordinator:
\begin{itemize}
	\item Identifier: \EC
	\item Public certificate: $Z_{\EC}$, signed by \CA at time $t$
	\item Public verification key: $\VK{\EC}$ 
	\item Private signature key: $\SK{\EC}$
\end{itemize}

Bulletin Board:
\begin{itemize}
	\item Identifier: \UB
	\item Public certificate: $Z_{\UB}$, signed by \CA at time $t$
	\item Public verification key: $\VK{\UB}$ 
	\item Private signature key: $\SK{\UB}$
\end{itemize}

\subsubsection{Election Trustees}

Talliers: (for $1\leq j\leq r$)
\begin{itemize}
	\item Identifier: $\Tallier{j}$
	\item Public certificate: $Z_{j}$, signed by \CA at time $t_j$
	\item Public verification key: $\vk{j}$ 
	\item Private signature key: $\sk{j}$
\end{itemize}

Mixers: (for $1\leq k\leq m$)
\begin{itemize}
	\item Identifier: $\Mixer{k}$
	\item Public certificate: $Z_{k}$, signed by \CA at time $t_k$
	\item Public verification key: $\vk{k}$ 
	\item Private signature key: $\sk{k}$
\end{itemize}

\subsubsection{Election Participants}

Election administration:
\begin{itemize}
	\item Identifier: \EA
	\item Public certificate: $Z_{\EA}$, signed by \CA at time $t$
	\item Public verification key: $\VK{\EA}$ 
	\item Private signature key: $\SK{\EA}$
\end{itemize}

Voters: (for $1\leq i\leq n$)
\begin{itemize}
	\item Identifier: $\Voter{i}$
	\item Personal credentials: $\cred{i}$ issued by the \CA or an affiliated identity provider.
\end{itemize}

%-----------------------------------------------------------------------------------------------
\subsection{At all times}\label{Atalltimes}
%-----------------------------------------------------------------------------------------------

\UB notifies registered listeners about published messages. Anybody can register itself as a listener.
(This section might be changed to a description of the properties of the bulletin board(certified read,multi tenant))

%-----------------------------------------------------------------------------------------------
\subsection{Registration}\label{registration}
%-----------------------------------------------------------------------------------------------

Registration can take place at any time, possibly long before an election starts. A registered voter can use the private signature key multiple times.

\subsubsection{First-Time Registration}

$\Voter{i}$ performs the following steps:
\begin{enumerate}
	\item Choose $\sk{i}\in_R \mathbb{Z}_q$ uniformly at random.
	\item Compute $\vk{i} = g^{\sk{i}}\bmod{p}$.
	\item Generate $\pi_{\sk{i}}=\mathit{NIZKP}\{(\sk{i}):\vk{i}=g^{\sk{i}}\bmod{p}\}$ to prove knowledge of $\sk{i}$ (see \subsecref{proof_reg} for details).
	\item Send $(\Voter{i},\cred{i},\vk{i},\pi_{\sk{i}})$ to \CA.
\end{enumerate}

Upon receipt, \CA performs the following steps:
\begin{enumerate}[resume]
	\item Check validity of $(\Voter{i},\cred{i})$.
	\item Check correctness of $\pi_{\sk{i}}$ (see \subsecref{proof_reg} for details).
	\item Determine current timestamp $t_i$.
	\item Compute H(\Voter{i})
	\item Compute $Z_i=\mathit{Certify}_{\SK{\CA}}(H(\Voter{i}),\vk{i},t_i)=(H(\Voter{i}),\vk{i},t_i,\CA,S_i)$.
	\item Publish $Z_i$ on \UB.
\end{enumerate}

\subsubsection{Registration Renewal}
The above procedure allows $\Voter{i}$ to renew the registration at any time, simply by performing the same steps again. The new certificate $\bar{Z}_i=(\Voter{i},\vkbar{i},\bar{t}_i,\CA,\bar{S}_i)$ will contain a timestamp $\bar{t}_i>t_i$, which will implicitly disqualify any former certificate $Z_i=(\Voter{i},\vk{i},t_i,\CA,S_i)$ in current or future elections. \CA should warn $\Voter{i}$ before issuing a new certificate.

%-----------------------------------------------------------------------------------------------
\subsection{Election Setup}
%-----------------------------------------------------------------------------------------------

The following tasks can be performed in advance, possibly long before the election starts.

\subsubsection{Initialization}

Upon request from \EA to run an election, \EC performs the following steps: 
\begin{enumerate}
	\item Choose unique \emph{election identifier} $\eid$.
	\item Select $Z_{\EA}$ from the \UB. Check that $\mathit{Verify}_{\VK{\CA}}(Z_{\EA})=\mathit{accept}$.
	\item Generate signature $S_{\EA}=\mathit{Sign}_{\SK{\EC}}(\eid||Z_{\EA})$. 
	\item Publish $(\EC,\eid,Z_{\EA},S_{\EA})$ on \UB.
\end{enumerate}


\subsubsection{Election Definition}

\EA performs the following steps: 
\begin{enumerate}
	\item Define textual description of the election event $\descr$.
	\item Define security parameter $\ell$ (e.g.\ $\ell=2048$ bits)
	\item Define talliers $T=\{\Tallier{1}\ldots,\Tallier{r}\}$.
	\item For each $\Tallier{j}\in T$, select $Z_{j}$ from \UB and check that $\mathit{Verify}_{\VK{\CA}}(Z_{j})=\mathit{accept}$. Let $\mathcal{Z}_{T}=\{Z_j:1\leq j\leq r\}$.
	\item Define mixers $M=\{\Mixer{1}\ldots,\Mixer{m}\}$.
	\item For each $\Mixer{k}\in M$, select $Z_{k}$ from \UB and check that $\mathit{Verify}_{\VK{\CA}}(Z_{k})=\mathit{accept}$. Let $\mathcal{Z}_{M}=\{Z_k:1\leq k\leq m\}$.
	\item Generate signature $S_{\descr}=\mathit{Sign}_{\SK{\EA}}(\eid||\descr||\ell||\mathcal{Z}_{T}||\mathcal{Z}_{M})$.
	\item Publish $(\EA,\eid,\descr,\ell,\mathcal{Z}_{T},\mathcal{Z}_{M},S_{\descr})$ on \UB.
\end{enumerate}

\subsubsection{Parameter Generation}

\EC performs the following steps:\footnote{The same set of parameters may be used for several elections with the same security parameter.}
\begin{enumerate}
	\item Define ElGamal parameters $P$ (of length $\ell$ bits), $Q = (P-1)/2$, and $G \in\{2,3,4\}$ (the smallest possible value). We use capital letters to distinguish them from Schnorr parameters.
	\item Generate signature $S_{\mathit{PQG}}=\mathit{Sign}_{\SK{\EC}}(\eid||P||Q||G)$.
	\item Publish $(\EC,\eid,P,Q,G,S_{\mathit{PQG}})$ on \UB.
\end{enumerate}

\subsubsection{Distributed Key Generation}

Each $\Tallier{j}\in T$ performs the following steps:
\begin{enumerate}
	\item Check that $\mathit{Verify}_{\VK{\EC}}(\eid||P||Q||G,S_{\mathit{PQG}})=\mathit{accept}$.
	\item Choose $x_j\in_R\mathbb{Z}_Q$ uniformly at random.
	\item Compute $y_j = G^{x_j} \bmod{P}$.
	\item Generate $\pi_{x_j}=\mathit{NIZKP}\{(x_j):y_j=G^{x_j}\bmod{P}\}$ to prove knowledge of $x_j$ (see \subsecref{proof_key_gen} for details).
	\item Generate signature $S_{y_j}=\mathit{Sign}_{\sk{j}}(\eid||y_j||\pi_{x_j})$.
	\item Publish $(\Tallier{j},\eid,y_j,\pi_{x_j},S_{y_j})$ on \UB.
\end{enumerate}

\EC performs the following steps:
\begin{enumerate}[resume]
	\item For each $\Tallier{j}\in T$, do the following:
	\begin{enumerate}
		\item Check that $\mathit{Verify}_{\vk{j}}(\eid||y_j||\pi_{x_j},S_{y_j})=\mathit{accept}$.
		\item Check correctness of $\pi_{x_j}$ (see \subsecref{proof_key_gen} for details).
	\end{enumerate}
	\item Compute $y=\prod_j y_j\bmod{P}$.
	\item Generate signature $S_y=\mathit{Sign}_{\SK{\EC}}(\eid||y)$.
	\item Publish $(\EC,\eid,y,S_y)$ on \UB.
\end{enumerate}

\subsubsection{Constructing the Election Generator}

Let $g_0=g$ the publicly known generator of the Schnorr signature scheme. Each $\Mixer{k}\in M$ performs the following steps (in ascending order for $1\leq k\leq m$):
\begin{enumerate}
	\item Choose $\alpha_k\in_R\mathbb{Z}_q$ at random.
	\item Compute blinded generator $g_k = g_{k-1}^{\alpha_k}\bmod{p}$.
	\item Generate $\pi_{\alpha_k}=\mathit{NIZKP}\{(\alpha_k):g_k=g_{k-1}^{\alpha_k}\bmod{p}\}$ to prove knowledge of $\alpha_k$ (see \subsecref{proof_fresh} for details).
	\item Generate signature $S_{g_k}=\mathit{Sign}_{\sk{k}}(\eid||g_k||\pi_{\alpha_k})$.
	\item Publish $(\Mixer{k},\eid,g_k,\pi_{\alpha_k},S_{g_k})$ on \UB.
\end{enumerate}

\EC performs the following steps:
\begin{enumerate}[resume]
	\item For each $\Mixer{k}\in M$, do the following:
	\begin{enumerate}
		\item Check that $\mathit{Verify}_{\vk{k}}(\eid||g_k||\pi_{\alpha_k},S_{g_k})=\mathit{accept}$.
		\item Check correctness of $\pi_{\alpha_k}$ (see \subsecref{proof_fresh} for details).
	\end{enumerate}
	\item Let $\hat{g}=g_m$ be the \emph{election generator}.
	\item Generate signature $S_{\hat{g}}=\mathit{Sign}_{\SK{\EC}}(\eid||\hat{g})$.
	\item Publish $(\EC,\eid,\hat{g},S_{\hat{g}})$ on \UB. 
\end{enumerate}

%-----------------------------------------------------------------------------------------------
\subsection{Election Preparation}\label{preparation}
%-----------------------------------------------------------------------------------------------

The following tasks are performed shortly before starting the election.

\subsubsection{Definition of Election Options}

\EA performs the following steps:
\begin{enumerate}
	\item Define the set of choices $C$ and a rule set $R$ describing the set $\mathcal{V}^*=\mathit{Votes}(C,R)$ of valid \emph{election options}, where $\mathit{Votes}$ is a publicly known function (see \secref{choices} for details).
	\item Generate signature $S_C=\mathit{Sign}_{\SK{\EA}}(\eid||C||R)$.
	\item Publish $(\EA,\eid,C,R,S_C)$ on \UB.
\end{enumerate}

\subsubsection{Publication of Election Data}

\EC performs the following steps:
\begin{enumerate}
	\item Check that $\mathit{Verify}_{\VK{\EA}}(\eid||C||R,S_C)=\mathit{accept}$.
	\item Generate signature $S_{data}=\mathit{Sign}_{\SK{\EC}}(\eid||\EA||\descr||P||Q||G||y||\hat{g}||C||R)$.
	\item Publish $(\EC,\eid,\EA,\descr,P,Q,G,y,\hat{g},C,R,S_{data})$ on \UB.
\end{enumerate}

\subsubsection{Electoral Roll Preparation}

\EA performs the following steps:
\begin{enumerate}
	\item Define the \emph{electoral roll} as the set of eligible Voters $V=\{\Voter{1},\ldots,\Voter{n}\}$.
	\item Compute $H_V=\{H(\Voter{1}),\ldots,H(\Voter{n})\}$.
	\item Generate signature $S_{V}=\mathit{Sign}_{\SK{\EA}}(\eid||H_V)$.
	\item Publish $(\EA,\eid,H_V,S_{V})$ on \UB.
\end{enumerate}

\EC performs the following steps:
\begin{enumerate}[resume]
	\item Check that $\mathit{Verify}_{\VK{\EA}}(\eid||H_V,S_{V})=\mathit{accept}$.
	\item For every $H(\Voter{i})\in H_V$, select the most recent $Z_i$ from the public certificate directory. For each $Z_i$, check that $\mathit{Verify}_{\VK{\CA}}(Z_i)=\mathit{accept}$. If yes, add it to the list of registered voters $\mathcal{Z}_V=\{Z_1,\ldots,Z_n\}$.\footnote{In many contexts, the number of registered voters is likely to be much smaller than the number of eligible voters.}
	\item Generate signature $S_V=\mathit{Sign}_{\SK{\EC}}(\eid,\mathcal{Z}_V)$.
	\item Publish $(\EC,\eid,\mathcal{Z}_V,S_V)$ on \UB.
\end{enumerate}


\subsubsection{Mixing the Public Verification Keys}

Let $\mathit{VK}_0=\{\vk{1},\ldots,\vk{n}\}$ be the (ordered) set of public verification keys in $\mathcal{Z}_V$. Repeat the following steps for each $\Mixer{k}\in M$ (in ascending order for $1\leq k\leq m$):
\begin{enumerate}
	\item Shuffle the set of public verification keys $\mathit{VK}_{k-1}$ into $\mathit{VK}_{k}$:
	\begin{enumerate}
		\item Compute blinded verification key $\vkprime{i}=\vk{i}^{\alpha_k}$ for every $\vk{i}\in\mathit{VK}_{k-1}$.
		\item Choose permutation $\psi_k:[1,n]\rightarrow[1,n]$ uniformly at random.
		\item Let $\mathit{VK}_k=\{\vkprime{\psi_k(i)}: 1\leq i\leq n\}=\mathit{Shuffle}_{\psi_k}(\mathit{VK}_{k-1},\alpha_k)$ be the new (ordered) set of public verification keys shuffled according to $\psi_k$.
	\end{enumerate}
	\item Generate $\pi_{\psi_k}=\mathit{NIZKP}\{(\psi_k,\alpha_k):g_k=g_{k-1}^{\alpha_k}\wedge \mathit{VK}_{k}=\mathit{Shuffle}_{\psi_k}(\mathit{VK}_{k-1},\alpha_k)\}$ using Wikström's proof of a shuffle (see \secref{proof_mix_keys} for details).
	\item Generate signature $S_{\mathit{VK}_k}=\mathit{Sign}_{\sk{k}}(\eid||\mathit{VK}_k||\pi_{\psi_k})$.
	\item Publish $(\Mixer{k},\eid,\mathit{VK}_k,\pi_{\psi_k},S_{\mathit{VK}_k})$ on \UB.
\end{enumerate}

\EC performs the following steps:
\begin{enumerate}[resume]
	\item For each $\Mixer{k}\in M$, do the following:
	\begin{enumerate}
		\item Check that $\mathit{Verify}_{\vk{k}}(\eid||\mathit{VK}_k||\pi_{\psi_k},S_{\mathit{VK}_k})=\mathit{accept}$.
		\item Check correctness of $\pi_{\psi_k}$ (see \secref{proof_mix_keys} for details).
	\end{enumerate}
	\item Let $\mathit{VK}'=\mathit{VK}_m=\{\vkprime{\psi(i)}:1\leq i\leq n\}$ for $\psi=\psi_m\circ\cdots\circ\psi_1$.
	\item Generate signature $S_{\mathit{VK}'}=\mathit{Sign}_{\SK{\EC}}(\eid,\mathit{VK}')$.
	\item Publish $(\EC,\eid,\mathit{VK}',S_{\mathit{VK}'})$ on \UB.
\end{enumerate}

%-----------------------------------------------------------------------------------------------
\subsection{Election Period}\label{election_period}
%-----------------------------------------------------------------------------------------------



\subsubsection{Vote Creation and Casting}
Consider the case of $\Voter{i}\in V$ creating and casting a vote. To do so, $\Voter{i}$ performs the following steps:
\begin{enumerate}
	\item Retrieve $(\EC,\eid,\EA,\descr,P,Q,G,y,\hat{g},C,R,S_{data})$ from \UB.\footnote{$\EA$ and $\descr$ are not explicitly required in the following steps. But it is important for $\Voter{i}$ to learn the identity of the election administration and the content of the election.}
	\item Check that $\mathit{Verify}_{\VK{\EC}}(\eid||\EA||\descr||P||Q||G||y||\hat{g}||C||R,S_{data})=\mathit{accept}$.
	\item Determine the set $\mathcal{V}^*=\mathit{Votes}(C,R)$ of election options.\footnote{The set $\mathcal{V}^*$ is not constructed explicitly, it is rather provided implicitly by a proper voting GUI on the voter's client computer.}
	\item Choose vote $v_i\in \mathcal{V}^*$.
	\item Represent $v_i$ as an integer $m_i'=\mathit{Encode}_{C,R}(v_i) \in \mathbb{Z}_Q$.
	\item Compute $m_i=G(m_i') \in G_Q$.
	\item Choose $r_i\in_R\mathbb{Z}_Q$ uniformly at random.
	\item Compute $E_i=\mathit{Enc}_y(m_i,r_i)=(a_i,b_i)$.
	\item Generate $\pi_{r_i}=\mathit{NIZKP}\{(m_i,r_i):E_i=\mathit{Enc}_y(m_i,r_i)\}$ to prove knowledge of $(m_i,r_i)$. Note that if $E_i=(a_i,b_i)=(G^{r_i},m_i\cdot y^{r_i})$ is an ElGamal encryption, then this proof is equivalent to the proof $\mathit{NIZKP}\{(r_i):a_i=G^{r_i}\}$, which implies knowledge of $m_i$ (see \subsecref{proof_vote} for details).
	\item Generate signature $S_i=\mathit{Sign}_{\sk{i}}(\eid||E_i||\pi_{r_i})$ using $\hat{g}$.
	\item Compute anonymous verification key $\vkprime{j}=\hat{g}^{\sk{i}}$, where $j=\psi(i)$.
	\item Publish ballot $B_i=(\vkprime{j},\eid,E_i,\pi_{r_i},S_i)$ on \UB.
\end{enumerate}
Upon receipt of $B_i$, \UB performs the following tests:
\begin{enumerate}[resume]
	\item Check that $\vkprime{j}$ belongs to an eligible voter: $\vkprime{j}\in \mathit{VK}'\cup \bar{\mathit{VK}}'$.
	\item Check that $\Voter{i}$ has not previously submitted another ballot:\footnote{Since re-voting is not supported, only the first ballot counts.}
	\begin{enumerate}
		\item Check that no ballot on \UB contains $\vkprime{j}$.
		\item If $\vkprime{j}\in \bar{VK}'\cup\hat{VK}'$, check that no other ballot on \UB contains a different key of $\Voter{i}$ from $\bar{VK}'\cup\hat{VK}'$.
	\end{enumerate}
	\item Check validity of $B_i$
	\begin{enumerate}
		\item Check that $\mathit{Verify}_{\vkprime{j}}(\eid||E_i||\pi_{r_i},S_i)=\mathit{accept}$ using $\hat{g}$.
		\item Optional: Check correctness of $\pi_{r_i}$ (see \subsecref{proof_vote} for details).
	\end{enumerate}
\end{enumerate}
\UB publishes $B_i$, if all tests succeed.

\subsubsection{Closing the Electronic Urn}

When the election period is over, \EC performs the following steps:
\begin{enumerate}
	\item For each $B_i=(\vkprime{j},\eid,E_i,\pi_{r_i},S_i)$, do the following:
	\begin{enumerate}
		\item Check that $\vkprime{j}\in \mathit{VK}'\cup \bar{\mathit{VK}}'$.
		\item Check that no other (more recent) ballot contains $\vkprime{j}$
		\item If $\vkprime{j}\in \bar{VK}'\cup\hat{VK}'$, check that no other (more recent) ballot on \UB contains a different key of $\Voter{i}$ from $\bar{VK}'\cup\hat{VK}'$.
		\item Check that $\mathit{Verify}_{\vkprime{j}}(\eid||E_i||\pi_{r_i},S_i)=\mathit{accept}$ using $\hat{g}$.
		\item Check correctness of $\pi_{r_i}$ (see \subsecref{proof_vote} for details).
	\end{enumerate}
	\item Let $\mathcal{B}$ be the set of ballot $B_i$, for which all above checks succeed. 
	\item Generate signature $S_{\mathcal{B}}=\mathit{Sign}_{\SK{\EC}}(\eid||\mathcal{B})$.
	\item Publish $(\EC,\eid,\mathcal{B},S_{\mathcal{E}})$ on \UB.
\end{enumerate}

%-----------------------------------------------------------------------------------------------
\subsection{Mixing and Tallying}
%-----------------------------------------------------------------------------------------------

\subsubsection{Mixing the Encryptions}

Let $\mathcal{E}_0=\{E_1,\ldots,E_N\}$, $N\leq n$, be the (ordered) set of encrypted votes in $\mathcal{B}$. Repeat the following steps for each $\Mixer{k}\in M$ (in ascending order for $1\leq k\leq m$):
\begin{enumerate}
	\item Shuffle the set encrypted votes $\mathcal{E}_{k-1}$ into $\mathcal{E}_{k}$:
	\begin{enumerate}
		\item Choose $\bar{r}_{k}=(r_{1k},\ldots,r_{Nk})\in_R\mathbb{Z}_q^N$ uniformly at random and compute $E'_i=\mathit{ReEnc}_y(E_i,r_{ik})$ for every $E_i\in \mathcal{E}_{k-1}$.
		\item Choose permutation $\tau_k:[1,N]\rightarrow[1,N]$ uniformly at random.
		\item Let $\mathcal{E}_k=\{E'_{\tau_k(i)}: 1\leq i\leq N\}=\mathit{Shuffle}_{\tau_k}(\mathcal{E}_{k-1},\bar{r}_k)$ be the new (ordered) set of encrypted votes shuffled according to $\tau_k$.
	\end{enumerate}
	\item Generate $\pi_{\tau_k}=\mathit{NIZKP}\{(\tau_k,\bar{r}_k):\mathcal{E}_{k}=\mathit{Shuffle}_{\tau_k}(\mathcal{E}_{k-1},\bar{r}_k)\}$ using Wikström's proof of a shuffle (see \secref{proof_mix_encryptions} for details).
	\item Generate signature $S_{\mathcal{E}_k}=\mathit{Sign}_{\sk{k}}(\eid||\mathcal{E}_k||\pi_{\tau_k})$.
	\item Publish $(\Mixer{k},\eid,\mathcal{E}_k,\pi_{\tau_k},S_{\mathcal{E}_k})$ on \UB.
\end{enumerate}

\EC performs the following steps:
\begin{enumerate}[resume]
	\item For each $\Mixer{k}\in M$, do the following:
	\begin{enumerate}
		\item Check that $\mathit{Verify}_{\vk{k}}(\eid||\mathcal{E}_k||\pi_{\tau_k},S_{\mathcal{E}_k})=\mathit{accept}$ 
		\item Check correctness of $\pi_{\tau_k}$ (see \secref{proof_mix_encryptions} for details).
	\end{enumerate}
	\item Let $\mathcal{E}'=\mathcal{E}_m=\{E_{\tau(i)}':1\leq i\leq N\}$ for $\tau=\tau\circ\cdots\circ\tau_1$.
	\item Generate signature $S_{\mathcal{E}'}=\mathit{Sign}_{\SK{\EA}}(\eid||\mathcal{E}')$.
	\item Publish $(\EC,\eid,\mathcal{E}',S_{\mathcal{E}'})$ on \UB.
\end{enumerate}

\subsubsection{Decrypting the Votes}
Each $\Tallier{j}\in T$ performs the following steps:
\begin{enumerate}
	\item Check that $\mathit{Verify}_{\VK{\EC}}(\eid||\mathcal{E}',S_{\mathcal{E}'})=\mathit{accept}$.
	\item Let $\bar{a}=(a_1,\ldots,a_N)$ for $(a_i,b_i)\in\mathcal{E}'$. 
	\item Compute $\bar{a}_j = (a_{1j},\ldots,a_{Nj})$, where $a_{ij} = a_i^{-x_j}\bmod{P}$.
	\item Generate $\pi_{x_j}'=\mathit{NIZKP}\{(x_j):[y_j=G^{x_j}\bmod{P}] \wedge \left[\bigwedge_i a_{ij} = a_i^{-x_j}\bmod{P}\right]\}$ to prove knowledge of $x_j$ (see \subsecref{proof_decryption} for details).
	\item Generate signature $S_{\bar{a}_j}=\mathit{Sign}_{\sk{j}}(\eid||\bar{a}_j||\pi_{x_j}')$.
	\item Publish $(\Tallier{j},\eid,\bar{a}_j,\pi_{x_j}',S_{\bar{a}_j})$ on \UB.
\end{enumerate}

\EC performs the following steps:
\begin{enumerate}[resume]
	\item For each $\Tallier{j}\in T$, do the following:
	\begin{enumerate}
		\item Check that $\mathit{Verify}_{\vk{j}}(\eid||\bar{a}_j||\pi_{x_j}',S_{\bar{a}_j})=\mathit{accept}$
		\item Check correctness of $\pi_{x_j}'$ (see \subsecref{proof_decryption} for details).
	\end{enumerate}
	\item For all $1\leq i\leq N$, do the following:
	\begin{enumerate}
		\item Compute $m_i=b_i\cdot\prod_j a_{ij}\bmod{P}$.
		\item Compute $m'_i = G^{-1}(m_i)$.
		\item Compute $v_i = \mathit{Decode}_{C,R}(m'_i)$.
	\end{enumerate}
	\item Let $\mathcal{V}=\{v_1,\ldots,v_N\}\cap \mathcal{V}^*$ be the list of valid plaintext votes.
	\item Generate signature $S_{\mathcal{V}}=\mathit{Sign}_{\SK{\EC}}(\eid||\mathcal{V})$.
	\item Publish $(\EC,\eid,\mathcal{V},S_{\mathcal{V}})$ on \UB.
\end{enumerate}

%===============================================================================================
\section{Late Registration}
%===============================================================================================

In principle, the previously described protocol requires the voter to register prior to an election. In some contexts, however, it will be impossible to enforce that \emph{all} voters have registered when the election starts. Those without a registration would then be excluded from casting a vote.

Let $\Voter{i}$ be an eligible voter in a current election. This can be tested by checking if $H(\Voter{i})\in H_V$, where $V$ is denotes the set of eligible voters and $H_V$ the corresponding set of hash values as published on \UB (see \subsecref{preparation}). A late registration invokes the procedure described below.

\subsection{Election Period}

\subsubsection{New Registration} \label{newregistation}

Upon notification of a newly registered voter $\Voter{i}$ during the election period of the election $\eid$, \EC performs the following steps:
\begin{enumerate}
	\item Check if $H(\Voter{i})\in H_V$.
	\item Select the new certificate $\bar{Z}_i=(\Voter{i},\vkbar{i},\bar{t}_i,\CA,\bar{C}_i)$ from the public certificate directory. Check that $\mathit{Verify}_{\VK{\CA}}(\bar{Z}_i)=\mathit{accept}$.
	\item Generate signature $S_{\bar{Z}_i}=\mathit{Sign}_{\SK{\EC}}(\eid,\bar{Z}_i)$.
	\item Publish $(\EC,\eid,\bar{Z}_i,S_{\bar{Z}_i})$ on \UB. Let $\bar{\mathcal{Z}}_V$ denote the current set of certificates added during the election period.
\end{enumerate}

Let $\vkbar{i,0}=\vkbar{i}$ be the new verification key from $\bar{Z}_i$. Repeat the following steps for each $\Mixer{k}\in M$ (in ascending order for $1\leq k\leq m$):\footnote{Note that this procedure corresponds to the borderline case of the general mixing procedure for a single innput public key (with a simplified proof).}
\begin{enumerate}[resume]
	\item Compute $\vkbar{i,k}=\vkbar{i,k-1}^{\alpha_k}$.
\	\item Generate $\pi_{\vkbar{i,k}}=\mathit{NIZKP}\{(\alpha_k):g_k=g_{k-1}^{\alpha_k}\wedge\vkbar{i,k}=\vkbar{i,k-1}^{\alpha_k}\}$ (see \subsecref{proof_reg_new} for details).
	\item Generate signature $S_{\vkbar{i,k}}=\mathit{Sign}_{\sk{k}}(\eid||\vkbar{i,k}||\pi_{\vkbar{i,k}})$.
	\item Publish $(\Mixer{k},\eid,\vkbar{i,k},\pi_{\vkbar{i,k}},S_{\vkbar{i,k}})$ on \UB.
\end{enumerate}

\EC performs the following steps:
\begin{enumerate}[resume]
	\item For each $\Mixer{k}\in M$, do the following:
	\begin{enumerate}
		\item Check that $\mathit{Verify}_{\vk{k}}(\eid||\vkbar{i,k}||\pi_{\vkbar{i,k}},S_{\vkbar{k}})=\mathit{accept}$.
		\item Check correctness of $\pi_{\vkbar{i,k}}$ (see \subsecref{proof_reg_new} for details).
	\end{enumerate}
	\item Let $\vkbarprime{i}=\vkbar{i,m}=\vkbar{i}^{\alpha}$.
	\item Generate signature $S_{\vkbarprime{i}}=\mathit{Sign}_{\SK{\EC}}(\eid,\Voter{i},\vkbarprime{i})$.
	\item Publish $(\EC,\eid,\Voter{i},\vkbarprime{i},S_{\vkbarprime{i}})$ on \UB. Let $\bar{\mathit{VK}}'$ denote the set of all public keys $\vkbarprime{i}$ added during the election period.
\end{enumerate}

\subsubsection{Late Renewal of Registration}

Essentially the same steps are repeated, if the current set $\mathcal{Z}_V \cup \bar{\mathcal{Z}}_V$ contains an earlier certificate $\hat{Z}_i=(\Voter{i},\vkhat{i},\hat{t}_i,\CA,\hat{C}_i)$ of $\Voter{i}$. Note that the first part of the above procedure is not repeated, since $\hat{Z}_i\in\mathcal{Z}_V \cup \bar{\mathcal{Z}}_V$ implies that $\hat{Z}_i$ has already been verified. Let $\vkhat{i,0}=\vkhat{i}$ be the former verification key from $\hat{Z}_i$. Repeat the following steps for each $\Mixer{k}\in M$ (in ascending order for $1\leq k\leq m$):\footnote{Again, this procedure corresponds to the borderline case of the general mixing procedure for a single innput public key (with a simplified proof).}

\begin{enumerate}
	\item Compute $\vkhat{i,k}=\vkhat{i,k-1}^{\alpha_k}$.
\	\item Generate $\pi_{\vkhat{i,k}}=\mathit{NIZKP}\{(\alpha_k):g_k=g_{k-1}^{\alpha_k}\wedge\vkhat{i,k}=\vkhat{i,k-1}^{\alpha_k}\}$ (see \subsecref{proof_reg_new} for details).
	\item Generate signature $S_{\vkhat{i,k}}=\mathit{Sign}_{\sk{k}}(\eid||\vkhat{i,k}||\pi_{\vkhat{i,k}})$.
	\item Publish $(\Mixer{k},\eid,\vkhat{i,k},\pi_{\vkhat{i,k}},S_{\vkhat{i,k}})$ on \UB.
\end{enumerate}

\EC performs the following steps:
\begin{enumerate}[resume]
	\item For each $\Mixer{k}\in M$, do the following:
	\begin{enumerate}
		\item Check that $\mathit{Verify}_{\vk{k}}(\eid||\vkhat{i,k}||\pi_{\vkhat{i,k}},S_{\vkhat{i,k}})=\mathit{accept}$.
		\item Check correctness of $\pi_{\vkhat{i,k}}$ (see \subsecref{proof_reg_new} for details).
	\end{enumerate}
	\item Let $\vkhatprime{i}=\vkhat{m}=\vkhat{i}^{\alpha}$.
	\item Generate signature $S_{\vkhatprime{i}}=\mathit{Sign}_{\SK{\EC}}(\eid,\Voter{i},\vkhatprime{i})$.
	\item Publish $(\EC,\eid,\Voter{i},\vkhatprime{i},S_{\vkhatprime{i}})$ on \UB. Let $\hat{\mathit{VK}}'$ denote the set of all public keys $\vkhatprime{i}$, which have been replaced by a new one during the election period.
\end{enumerate}


%%-----------------------------------------------------------------------------------------------
%\subsection{Universal Verification}
%%-----------------------------------------------------------------------------------------------

%===============================================================================================
\section{Details of Proofs}
%===============================================================================================

%-----------------------------------------------------------------------------------------------
\subsection{Registration}\label{proof_reg}
%-----------------------------------------------------------------------------------------------

This is a standard proof of knowledge of discrete logarithm (Schnorr):
\begin{align*}
\pi_{\sk{i}}=\mathit{NIZKP}\{(\sk{i}):\vk{i}=g^{\sk{i}}\bmod{p}\}=(t,c,s).
\end{align*}


\subsubsection{Generation}
Prover: $\Voter{i}$
\begin{enumerate}	
	\item Choose $\omega\in_R\mathbb{Z}_q$ uniformly at random.
	\item Compute $t=g^{\omega_j}\bmod{p}$.
	\item Compute $c=H(\vk{i}||t||\Voter{i})\bmod{q}$.
	\item Compute $s=\omega + c \cdot \sk{i} \bmod{q}$.
\end{enumerate}	

\subsubsection{Verification}
\begin{enumerate}
	\item Check that $c=H(\vk{i}||t||\Voter{i})\bmod{q}$.
	\item Compute $v=g^{s}\bmod{p}$.
	\item Compute $w=t\cdot \vk{i}^{c}\bmod{p}$.
	\item Check that $v=w$.
\end{enumerate}

%-----------------------------------------------------------------------------------------------
\subsection{Registration Renewal}\label{proof_reg_new}
%-----------------------------------------------------------------------------------------------

This is a standard proof of equality of discrete logarithm (Pedersen):
\begin{align*}
\pi_{\vkbar{i,k}}=\mathit{NIZKP}\{(\alpha_k):g_k=g_{k-1}^{\alpha_k}\wedge\vkbar{i,k}=\vkbar{i,k-1}^{\alpha_k}\}=(\bar{t},s).
\end{align*}

\subsubsection{Generation}
Prover: $\Mixer{k}$
\begin{enumerate}	
	\item Choose $\omega\in_R\mathbb{Z}_q$ uniformly at random.
	\item Compute $\bar{t}=(t_{1},t_{2})=(g_{k-1}^{\omega}\bmod{p},\vkbar{i,k-1}^{\omega}\bmod{p})$.
	\item Compute $c=H(g_k||\vkbar{i,k}||\bar{t}||\Mixer{k})\bmod{q}$.
	\item Compute $s=\omega + c\cdot \alpha_k\bmod{q}$.
\end{enumerate}

\subsubsection{Verification}
\begin{enumerate}
	\item Check that $c=H(g_k||\vkbar{i,k}||\bar{t}||\Mixer{k})\bmod{q}$.
	\item Compute $\bar{v}=(g_{k-1}^{s}\bmod{p},\vkbar{i,k-1}^{s}\bmod{p})$.
	\item Compute $\bar{w}=(t_{1}\cdot g_k^{c}\bmod{p},t_{2}\cdot \vkbar{i,k}^{c}\bmod{p})$.
	\item Check that $\bar{v}=\bar{w}$.
\end{enumerate}	

%-----------------------------------------------------------------------------------------------
\subsection{Distributed Key Generation}\label{proof_key_gen}
%-----------------------------------------------------------------------------------------------

This is a standard proof of knowledge of discrete logarithm (Schnorr):
\begin{align*}
\pi_{x_j}=\mathit{NIZKP}\{(x_j):y_j=G^{x_j}\bmod{P}\}=(t,c,s).
\end{align*}

\subsubsection{Generation}
Prover: $\Tallier{j}$
\begin{enumerate}	
	\item Choose $\omega\in_R\mathbb{Z}_Q$ uniformly at random.
	\item Compute $t=G^{\omega}\bmod{P}$.
	\item Compute $c=H(y_j||t||\Tallier{j})\bmod{Q}$.
	\item Compute $s=\omega + c\cdot x_j \bmod{Q}$.
\end{enumerate}	

\subsubsection{Verification}
\begin{enumerate}
	\item Check that $c=H(y_j||t||\Tallier{j})\bmod{Q}$.
	\item Compute $v=G^{s}\bmod{P}$.
	\item Compute $w=t\cdot y_j^{c}\bmod{P}$.
	\item Check that $v=w$.
\end{enumerate}

%-----------------------------------------------------------------------------------------------
\subsection{Constructing the Election Generator}\label{proof_fresh}
%-----------------------------------------------------------------------------------------------

This is a standard proof of knowledge of discrete logarithm (Schnorr):
\begin{align*}
\pi_{\alpha_k}=\mathit{NIZKP}\{(\alpha_k):g_k=g_{k-1}^{\alpha_k}\bmod{p}\}=(t,c,s).
\end{align*}
 
\subsubsection{Generation}
Prover: $\Mixer{k}$
\begin{enumerate}	
	\item Choose $\omega\in_R\mathbb{Z}_q$ uniformly at random.
	\item Compute $t=g_{k-1}^{\omega}\bmod{p}$.
	\item Compute $c=H(g_k||t||\Mixer{k})\bmod{q}$.
	\item Compute $s=\omega + c\cdot \alpha_k \bmod{q}$.
\end{enumerate}	

\subsubsection{Verification}
\begin{enumerate}
	\item Check that $c=H(g_k||t||\Mixer{k})\bmod{q}$.
	\item Compute $v=g_{k-1}^{s}\bmod{p}$.
	\item Compute $w=t\cdot g_k^{c}\bmod{p}$.
	\item Check that $v=w$.
\end{enumerate}

%-----------------------------------------------------------------------------------------------
\subsection{Mixing the Public Verification Keys}\label{proof_mix_keys}
%-----------------------------------------------------------------------------------------------

This proof is not yet implemented:
\begin{align*}
\pi_{\psi_k}=\mathit{NIZKP}\{(\psi_k,\alpha_k):g_k=g_{k-1}^{\alpha_k}\wedge \mathit{VK}_{k}=\mathit{Shuffle}_{\psi_k}(\mathit{VK}_{k-1},\alpha_k)\}.
\end{align*}

%-----------------------------------------------------------------------------------------------
\subsection{Vote Creation and Casting}\label{proof_vote}
%-----------------------------------------------------------------------------------------------

This is a standard proof of knowledge of discrete logarithm (Schnorr):
\begin{align*}
\pi_{r_i}=\mathit{NIZKP}\{(r_i):a_i=G^{r_i}\}=(t,c,s).
\end{align*}

\subsubsection{Generation}
Prover: $V_i$ (acting with $\vkprime{j}$ as anonymous identifier)
\begin{enumerate}	
	\item Choose $\omega\in_R\mathbb{Z}_Q$ uniformly at random.
	\item Compute $t=G^{\omega}\bmod{P}$.
	\item Compute $c=H(a_i||t||\vkprime{j})\bmod{Q}$.
	\item Compute $s=\omega + c\cdot r_i\bmod{Q}$.
\end{enumerate}

\subsubsection{Verification}
\begin{enumerate}
	\item Check that $c=H(a_i||t||\vkprime{j})\bmod{Q}$.
	\item Compute $v=G^{s}\bmod{P}$
	\item Compute $w=t\cdot a_i^{c}\bmod{P}$.
	\item Check that $v=w$.
\end{enumerate}

%-----------------------------------------------------------------------------------------------
\subsection{Mixing the Encryptions}\label{proof_mix_encryptions}
%-----------------------------------------------------------------------------------------------

This proof is not yet implemented:
\begin{align*}
\pi_{\tau_k}=\mathit{NIZKP}\{(\tau_k,\bar{r}_k):\mathcal{E}_{k}=\mathit{Shuffle}_{\tau_k}(\mathcal{E}_{k-1},\bar{r}_k)\}.
\end{align*}

%-----------------------------------------------------------------------------------------------
\subsection{Decrypting the Votes}\label{proof_decryption}
%-----------------------------------------------------------------------------------------------

This is a general equality proof with multiple functions:
\begin{align*}
\pi_{x_j}'=\mathit{NIZKP}\{(x_j):[y_j=G^{x_j}\bmod{P}] \wedge \left[\bigwedge_i a_{ij} = a_i^{-x_j}\bmod{P}\right]\}=(\bar{t},c,s).
\end{align*}

\subsubsection{Generation}
Prover: $\Tallier{j}$
\begin{enumerate}	
	\item Choose $\omega\in_R\mathbb{Z}_Q$ uniformly at random.
	\item Compute $\bar{t}=(t_{0},t_{1},\ldots,t_{N})=(G^{\omega}\bmod{P},a_1^{-\omega}\bmod{P},\ldots,a_N^{-\omega}\bmod{P})$.
	\item Compute $c=H(y_j||\bar{a}_j||\bar{t}||\Tallier{j})\bmod{Q}$.
	\item Compute $s=\omega + c\cdot x_j\bmod{Q}$.
\end{enumerate}

\subsubsection{Verification}
\begin{enumerate}
	\item Check that $c=H(y_j||\bar{a}_j||\bar{t}||\Tallier{j})\bmod{Q}$.
	\item Compute $\bar{v}=(G^{s}\bmod{P},a_1^{-s}\bmod{P},\ldots,a_N^{-s}\bmod{P})$.
	\item Compute $\bar{w}=(t_{0}\cdot y_j^{c}\bmod{P},t_{1}\cdot a_{1j}^{c}\bmod{P},\ldots,t_{N}\cdot a_{Nj}^{c}\bmod{P})$.
	\item Check that $\bar{v}=\bar{w}$.
\end{enumerate}	

%===============================================================================================
\section{Encoding Choices, Rules, and Vote}
%===============================================================================================

%-----------------------------------------------------------------------------------------------
\subsection{Choices and Rules}\label{choices}
%-----------------------------------------------------------------------------------------------

To allow a variety of different election types, we consider two finite sets, a set $C$ of possible \emph{election choices} and a set $R$ of \emph{election rules}. For each election choice $c\in C$ in a given election, the election system outputs the number of votes that $c$ has received from the voters. Each election rule in $R$ defines some constraints on how voters can distribute their votes among the election choices. We use $v(c)$ to denote this number for a particular voter. We distinguish three types of election rules:
\begin{itemize}
	\item \emph{Summation-Rule}: The sum of votes for election choices in a subset $C'\subseteq C$ is within a certain range $[a,b]$, i.e., $\sum\limits_{c\in C'}v(c)\in [a,b]$. Such rules will be denoted by $\Sigma:C'\rightarrow[a,b]$.
	\item \emph{Forall-Rule}: For each election choice in a subset $C'\subseteq C$, the number of votes is within a certain range $[a,b]$, i.e., $v(c)\in [a,b]$ for all $c\in C'$. Such rules will be denoted by $\forall:C'\rightarrow[a,b]$. 
	\item \emph{Distinctness-Rule}: For each election choice in a subset $C'\subseteq C$, the number of votes is either equal to $0$ or unique within $C'$, i.e., $v(c)>0$ implies $v(c)\not= v(c')$ for all other election choices $c'\in C'\setminus\{c\}$. Such rules will be denoted by $\not=\,:C'$.
\end{itemize}
Two or several sets of candidates and sets of rules can be combined to describe multiple elections that run in parallel. We call this operation \emph{composition of elections} and denote it by
\begin{align*}
	(C_1,R_1) \circ (C_2,R_2) = (C_1\cup C_2, R_1 \cup R_2)
\end{align*}
for two sets of choices $C_1,C_2$ and corresponding sets of rules $R_1,R_2$. Note that this can be used to describe party-list elections (see example below).

\subsubsection{Examples}

\begin{itemize}
\item Referendum: $1$-out-of-$2$
\begin{align*}
	C=\{yes,no\},~ 
	R=\left\{\begin{aligned}\Sigma:\{yes,no\}\rightarrow[1,1] \\ \forall:\{yes,no\}\rightarrow[0,1]\end{aligned}\right\}
\end{align*}

\item Referendum with Null Votes:
\begin{align*}
	C=\{yes,no\},~
	R=\left\{\begin{aligned}\Sigma:\{yes,no\}\rightarrow[0,1] \\ \forall:\{yes,no\}\rightarrow[0,1]\end{aligned}\right\}
\end{align*}
or
\begin{align*}
	C=\{yes,no,null\},~ 
	R=\left\{\begin{aligned}\Sigma:\{yes,no,null\}\rightarrow[1,1] \\ \forall:\{yes,no,null\}\rightarrow[0,1]\end{aligned}\right\}
\end{align*}

\item Multiple-Choice Referendum / Plurality Voting: $1$-out-of-$n$
\begin{align*}
	C=\{c_1,\ldots,c_n\},~ 
	R=\left\{\begin{aligned}\Sigma:\{c_1,\ldots,c_n\}\rightarrow[1,1] \\ \forall:\{c_1,\ldots,c_n\}\rightarrow[0,1]\end{aligned}\right\}
\end{align*}
Null votes can be handled as shown above.

\item Approval Voting: $n$-out-of-$n$ 
\begin{align*}
	C=\{c_1,\ldots,c_n\},~ 
	R=\left\{\begin{aligned}\forall:\{c_1,\ldots,c_n\}\rightarrow[0,1]\end{aligned}\right\}
\end{align*}

\item Range Voting: Up to $s$ votes per choice
\begin{align*}
	C=\{c_1,\ldots,c_n\},~ 
	R=\left\{\begin{aligned}\forall:\{c_1,\ldots,c_n\}\rightarrow[0,s]\end{aligned}\right\}
\end{align*}

\item Plurality-at-Large Voting / Limited Voting: $k$-out-of-$n$
\begin{align*}
	C=\{c_1,\ldots,c_n\},~ 
	R=\left\{\begin{aligned}\Sigma:\{c_1,\ldots,c_n\}\rightarrow[0,k] \\ \forall:\{c_1,\ldots,c_n\}\rightarrow[0,1]\end{aligned}\right\}
\end{align*}

\item Cumulative Voting: $k$ votes in total, up to $s\leq k$ votes per choice
\begin{align*}
	C=\{c_1,\ldots,c_n\},~ 
	R=\left\{\begin{aligned}\Sigma:\{c_1,\ldots,c_n\}\rightarrow[0,k] \\ \forall:\{c_1,\ldots,c_n\}\rightarrow[0,s]\end{aligned}\right\}
\end{align*}
Note that $k>n$ is allowed here.

\item Preferential Voting (Borda Count): Ranks from $1$ to $n$
\begin{align*}
	C=\{c_1,\ldots,c_n\},~ 
	R=\left\{\begin{aligned}\forall&:\{c_1,\ldots,c_n\}\rightarrow[1,n] \\ \not=&:\{c_1,\ldots,c_n\} \end{aligned}\right\}
\end{align*}
\item Preferential Voting (Borda Count): Ranks from $1$ to $k$ only
\begin{align*}
	C=\{c_1,\ldots,c_n\},~ 
	R=\left\{\begin{aligned}\forall&:\{c_1,\ldots,c_n\}\rightarrow[1,k] \\ \not=&:\{c_1,\ldots,c_n\} \end{aligned}\right\}
\end{align*}

\item Party-List Election with Cumulation: Composition of cumulative voting over a set of candidates and plurality voting over a set of party-lists
\begin{align*}
	C&=\{c_1,\ldots,c_n\}\cup\{\ell_1,\ldots,\ell_m\},\\
	R&=\left\{\begin{aligned}\Sigma:\{c_1,\ldots,c_n\}\rightarrow[0,k] \\ \forall:\{c_1,\ldots,c_n\}\rightarrow[0,s]\end{aligned}\right\} \cup
	\left\{\begin{aligned}\Sigma:\{\ell_1,\ldots,\ell_m\}\rightarrow[1,1] \\ \forall:\{\ell_1,\ldots,\ell_m\}\rightarrow[0,1]\end{aligned}\right\}
\end{align*}
Null votes (with respect to party-lists) can be handled as shown above.
\end{itemize}


%-----------------------------------------------------------------------------------------------
\subsection{Encoding Votes}\label{votes}
%-----------------------------------------------------------------------------------------------

Let $C=\{c_1,\ldots,c_n\}$ be a set of election choices and $v_i=v(c_i)\leq \rho_i$ the number of votes attributed to $c_i$ by a given voter. With $\rho_i$ we denote the maximum number of votes that the election rules in $R$ allow for $c_i$. The tuple $v=(v_1,\ldots,v_n)\in\mathcal{V}^*$ represents a valid vote, where $\mathcal{V}^*=\mathit{Votes}(C,R)$ denotes the set of all valid votes for given sets $C$ and $R$.

To encode $v\in \mathcal{V}^*$ as an integer, consider a bit string of length $B=\sum_{i=1}^n b_i$, where $b_i=\lfloor\log_2\rho_i\rfloor+1$ denotes the number of bits we reserve for each value $v_i$. Furthermore, let $B_i=\sum_{j=1}^{i-1}b_j$ be the number of bits in the bit sting \emph{prior} to $v_i$, i.e., $B_1=0$, $B_2=b_1$, $B_3=b_1+b_2$, \ldots, $B_{n+1}=B$. The encoding function $\mathit{Encode}_{C,R}:\mathcal{V}^*\rightarrow \{0,\ldots,2^B{-}1\}$ can then be defined as follows:
\begin{align*}
	\mathit{Encode}_{C,R}(v) = \sum_{i=1}^n v_i\cdot 2^{B_i}.
\end{align*}
Since some integers in $\{0,\ldots,2^B{-}1\}$ do not represent valid votes according to the election rules $R$, this encoding is not optimal in terms of memory space consumption. In the vast majority of cases, however, be believe that the size of the message space $G_Q$ of the ElGamal cryptosystem is large enough to support this encoding.

To decode an integer representation $x=\mathit{Encode}_{C,R}(v)$ back to $v=(v_1,\ldots,v_n)$, we must decompose the bit string into its components. Mathematically, this decomposition can be written as follows:
\begin{align*}
	\mathit{Decode}_{C,R}(x) = (v_1,\ldots,v_n),~\text{where}~	v_i=\lfloor x/2^{B_i} \rfloor \bmod{2^{b_i}}.
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{System Architecture}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\chapter{Conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\chapter*{Glossary}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%% Note (eric): The glossary package should be used here...
%
%\begin{description}
%
%\item[$\eid$] \emph{Election identifier}, a unique identifier identifying the election event. Typically composed by letters and digits. Defined by the election administration.
%
%\item[$\descr$] \emph{Election description}, a text describing the election event. Defined by the election administration.
%
%\item[$\sk{x}$] The \emph{signing key} of entity $x$. Used by entity $x$ for signing a given information.
%
%\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain} \bibliography{bibtex/library}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
